<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Design Patterns - Observer]]></title>
    <url>%2Fposts%2Fd4ab5f5e%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Observer pattern is map relationship between subject and observer, just like man subscribes newspaper from post office. Here subject is post office, and man is observer. Each time post office public newspaper,man will receive it, if he don’t interest any more, once he unsubscribe, he won’t receive newspaper in the next time. As long as he is willing, he can still subscribe to newspaper again. BriefFor most one-to-many situations, we can use the observer pattern. you can implement in different ways or use Observer class and Observalbe interface (both in java.util package). But interface-oriented is out belief, Observer class can not reduce coupling and has potential problem(observer order will not be consistent), so we implments this pattern without using above two. How to implement Observer Pattern?weather station provide weather status to various devices, once weather data update, weather station will broadcast to each one. then each device update data in real time. Here we create a interface, contains basic method, we implements these methods in specific class. interface instead of class, reduce coupling!12345public interface Subject &#123; public void add(Observer observer); public void remove(Observer observer); public void notifyAllObservers();&#125; Observer interface, we1234@FunctionalInterfacepublic interface Observer &#123; public void update(float temperature, float humidity, float pressure);&#125; device display method1234@FunctionalInterfacepublic interface DisplayInformation &#123; public void display();&#125; 12345678910111213141516171819202122232425262728293031323334353637public class WeatherData implements Subject &#123; private ArraryList&lt;Observer&gt; list; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; list = new ArrayList&lt;Observer&gt;() &#125; @Override public void add(Observer observer) &#123; list.add(observer); &#125; @Override public void remove(Observer observer) &#123; int index = list.indexof(observer); if(index &gt;= 0) &#123; list.remove(index); &#125; &#125; @Override public void notifyAllObservers() &#123; for(Observer observer : list) &#123; observer.update(temperature, humidity, pressure); &#125; &#125; public void setWeatherData(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyAllObservers(); &#125;&#125; Tow types observer,123456789101112131415161718public class CurrentWeather implements Observer, DisplayInformation &#123; private float temperature; private float humidity; private float pressure; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; &#125; @Override public void display() &#123; System.out.println("Now Weather:"); System.out.println("Temperature: "+temperature+" Humidity: "+humidity); &#125;&#125; 123456789101112131415161718public class ForecastWeather implements Observer, DisplayInformation &#123; private float temperature; private float humidity; private float pressure; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; &#125; @Override public void display() &#123; System.out.println("Forecast Weather:"); System.out.println("Humidity: "+humidity+" Pressure: "+pressure); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design Patterns - Strategy]]></title>
    <url>%2Fposts%2F5b825e54%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;After reading &lt;&lt; Head First Design Patterns &gt;&gt; chapter one,we know composition is better than inheritance in most case,use strategy pattern will reduce coupling and make code reusable better. Here is a example create a game character with strategy pattern Because each character has different weapon,so we don’t care about how he use it, the method of useWeapon is implements in specific class.1234@FunctionalInterfacepublic interface WeaponBehavior &#123; public void useWeapon();&#125; The method of setWeapon get parameter wb(just like function pointer in c++ or c),we don’t know which weapon he use now,that decided at runtime.This is a example about ploymorphism applied.123456789public abstract class Character &#123; WeaponBehavior wb; public abstract void fight(); public void setWeapon(WeaponBehavior wb) &#123; this.wb = wb; &#125;&#125; Three different types of attack use sword123456public class SwordBehavior implements WeaponBehavior &#123; @Override public void useWeapon() &#123; System.out.println("I use sword!") &#125;&#125; use knife123456public class KnifeBehavior implements WeaponBehavior &#123; @Override public void useWeapon() &#123; System.out.println("I use knife!"); &#125;&#125; use bow(just bow?! take some arraows!)123456public class BowBehavior implements WeaponBehavior &#123; @Override public void useWeapon() &#123; System.out.println("I use bow!"); &#125;&#125; Fighter defalut uses sword, but nobody want to use single weapon forever, use new type of weapon!123456789101112public class Fighter extends Character &#123; public Fighter() &#123; this.wb = new SwordBehavior(); // dafault use sword &#125; @Override public void fight() &#123; wb.useWeapon(); &#125;&#125; Let’s play games!12345678public class Test &#123; public static void main(String[] args) &#123; Fighter f = new Fighter(); f.fight(); // default weapon(sword) f.setWeapon(new BowBehavior()); // change weapon f.fight(); // now use bow &#125;&#125; output:12I use sword!I use bow!]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitwise!]]></title>
    <url>%2Fposts%2F8f8f81fb%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Similar problems LeetCode 136&nbsp;&nbsp;LeetCode 137&nbsp;&nbsp;LeetCode 260 about bit manipulation.we can use normal method to slove these three problems,we will be find that $T(n) = O(n^2)$ or $S(n) = O(n)$ ,how can we optimize? Humm,why not use bit state? It’s a brilliant method! In this way, we can get liner time complexity and without using extra space. Problem Igive you an array have a lot of numbers,each number apperance twice except one,find it out. 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for(int num:nums) &#123; ans ^= num; &#125; return ans; &#125;&#125;; $$T(n)=O(n)$$$$S(n) = O(1)$$ Problem IIgive you an array which each number appereance three times except one,find it out. 1234567891011121314class Solution&#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ones = 0, twos = 0; for (auto num : nums) &#123; ones = (ones^num) &amp; ~twos; twos = (twos^num) &amp; ~ones; &#125; return ones; &#125;&#125;; $$T(n) = O(n)$$$$S(n) = O(1)$$ Problem IIIgive you an array which each number appereance twice except two numbers,find them out. 123456789101112131415161718class Solution &#123;public: singleNumber(vector&lt;int&gt;&amp; nums) &#123; int diff = 0; for(int num:nums) diff ^= num; diff &amp;= -diff; vector&lt;int&gt; ans = &#123;0,0&#125;; for(int num:nums) &#123; if((num&amp;diff) == 0) ans[0] ^= num; else ans[1] ^= num; &#125; return ans; &#125;&#125;; $$T(n) = O(n)$$$$S(n) = O(1)$$]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is YAML?]]></title>
    <url>%2Fposts%2F281156b1%2F</url>
    <content type="text"><![CDATA[YAML (filename extensions .yml,.yaml) is a human-readable data serialization language. It is commonly used for configuration files, but could be used in many applications where data is being stored (e.g. debugging output) or transmitted (e.g. document headers). YAML’s Advantage YAML is easily readable by humans. YAML data is portable between programming languages. YAML matches the native data structures of agile language. YAML has a consistent model to support generic tools. YAML supports one-pass processing. YAML is expressive and extensible YAML is easy to implement and use. Syntax Whitespace indentation is used to denote structure; however, tab characters are never allowed as indentation. Comments begin with the number sign (#), can start anywhere on a line and continue until the end of the line. Comments must be separated from other tokens by white space characters. List members are denoted by a leading hyphen (-) with one member per line, or enclosed in square brackets ([ ]) and separated by comma space (,). Associative arrays are represented using the colon space (:) in the form key: value, either one per line or enclosed in curly braces ({ }) and separated by comma space (,). Strings are ordinarily unquoted, but may be enclosed in double-quotes ("), or single-quotes ('). Within double-quotes, special characters may be represented with C-style. Multiple documents within a single stream are separated by three hyphens (- - -). Three periods (. . .) optionally end a document within a stream. Repeated nodes are initially denoted by an ampersand (&) and thereafter referenced with an asterisk (*). TipsA light cheat sheet and format description can be find here.Use yamllint online or download plugins to check your YAML syntax validity. WarningYAML document can be encoded in UTF-8, UTF-16 and UTF-32,but if the parser is have JSON compatibility,it must be encoded in UTF-32. ExampleCollections Sequence of Scalars 123- banana- apple- peach Mapping Scalars to Scalars 123name: mikeage: 15gender: male Mapping Scalars to Sequence 1234fruit: - banana - apple - peach Sequence of Mappings 1234- name: mike age: 15 gender: male Sequence of Sequences 123456789101112131415161718# flow style- [name, age, gender]- [mike, 15 , male ]- [mary, 16 , female]# default style- - name - age - gender- - mike - 15 - male- - mary - 16 - female Mapping of Mappings 1234567891011121314# flow stylemike: &#123;age: 15, gender: male&#125;mary: &#123; age: 16, gender: female &#125;#default stylemary: age: 16 gender: femalemike: age: 15 gender: male Structure Two Documents in a stream 12345678910# kinds of fruit---- apple- banana- peach# kinds of food- bread- oatmeal- cheese Multiple Documents in different streams 123456789101112# record player track---time: 20:03:20player: Sammy Sosaaction: strike (miss)...---time: 20:03:47player: Sammy Sosaaction: grand slam... Repeated nodes usage 1234567891011121314151617181920---- step: &amp;id001 # defines anchor label &amp;id001 instrument: Lasik 2000 pulseEnergy: 5.4 pulseDuration: 12 repetition: 1000 spotSize: 1mm- step: &amp;id002 instrument: Lasik 2000 pulseEnergy: 5.0 pulseDuration: 10 repetition: 500 spotSize: 2mm- step: *id001 # refers to the first step (with anchor &amp;id001)- step: *id002 # refers to the second step- step: &lt;&lt;: *id001 spotSize: 2mm # redefines just this key, refers rest from &amp;id001- step: *id002 Mapping between Sequences 123456789? - Detroit Tigers - Chicago cubs: - 2001-07-23? [ New York Yankees, Atlanta Braves ]: [ 2001-07-02, 2001-08-12, 2001-08-14 ] Scalars In literals,newlines are preserved 123| In literals, new newlines are preserved. In the folded scalars,newlines become spaces 123&gt; In the folded scalars, new onlines become space. Multi-line Flow Scalars 123456plain: This unquoted scalar spans many lines.quoted: "So does this quoted scalar.\n" Tags Various Explicit Tags 12345678910111213---not-date: !!str 2002-04-28picture: !!binary | R0lGODlhDAAMAIQAAP//9/X 17unp5WZmZgAAAOfn515eXv Pz7Y6OjuDg4J+fn5OTk6enp 56enmleECcgggoBADs=application specific tag: !something | The semantics of the tag above may be different for different documents. Unordered Sets 1234567# Sets are represented as a# Mapping where each key is# associated with a null value--- !!set? Mark McGwire? Sammy Sosa? Ken Griff Ordered Mappings 1234567# Ordered maps are represented as# A sequence of mappings, with# each mapping having one key--- !!omap- Mark McGwire: 65- Sammy Sosa: 63- Ken Griffy: 58 ReferenceYAML.orgYAML-Wikipedia]]></content>
      <categories>
        <category>Markup Language</category>
      </categories>
      <tags>
        <tag>YAML</tag>
        <tag>Markup Language</tag>
      </tags>
  </entry>
</search>
